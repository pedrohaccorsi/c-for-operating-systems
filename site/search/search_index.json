{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to C for Operating Systems! # This is an online trainning, in which we will discuss Operating System concepts with a hands-on methodology. By the end of this course you'll have solid understanding of: Unix processes signals hierarchy C syscalls programming guidelines good practices Useful links # TBD","title":"Home"},{"location":"#welcome-to-c-for-operating-systems","text":"This is an online trainning, in which we will discuss Operating System concepts with a hands-on methodology. By the end of this course you'll have solid understanding of: Unix processes signals hierarchy C syscalls programming guidelines good practices","title":"Welcome to C for Operating Systems!"},{"location":"#useful-links","text":"TBD","title":"Useful links"},{"location":"processes/readme/","text":"Processes and programs # A program in Unix is a sequence of executable instructions. Apart from all its aspects, the only one that is of interest to us is the fact that a program is a sequence of instructions and data (on disk) that may potentially be executed at some point in time, maybe even multiple times, maybe even concurrently. Processes , in the other hand, are like a \"structure\" that wraps a running program and manages it, guarding its state, current directories, file handles, privileges and so on. You can run a program more than once, concurrently. For example, you can run two instances of a text editor, which edit two different texts. program and initial data are the same: it is the same editor. But the state inside each process is different: the text, the insert mode, cursor position and so on. From a programmers point of view, \u201cthe code is the same, but the variable values are different. User and Kernel mode # Whenever a Unix process does a system call (and at some other opportunities) the current process leaves the user context and the operating system code is being activated. This is privileged kernel code, and the activation is not quite a subroutine call, because not only is privileged mode activated, but also a kernel stack is being used and the CPU registers of the user process are saved. The kernel will then execute the system call on behalf of the user program, and then will try to exit the kernel. The typical way to leave the kernel is through the scheduler. The scheduler will review the process list and current situation. It will then decide into which of all the different user processes to exit. It will restore the chosen processes registers, then return into this processes context, using this processes stack. The chosen process may or may not be the one that made the system call. In short: Whenever you make a system call, you may (or may not) lose the CPU to another process . That\u2019s not too bad, because this other process at some point has to give up the CPU and the kernel will then return into our process as if nothing happened. Our program is not being executed linearly, but in a sequence of subjectively linear segments, with breaks inbetween. During these breaks the CPU is working on segments of other processes that are also runnable. Visual representation # In the diagram below we can see that the entity program is contained inside the entity process . Also, we can see that different process can comunicate between each other freely. However, in order to comunicate with the hardware, user processes must make system calls and have Kernel do it for them.","title":"Processes"},{"location":"processes/readme/#processes-and-programs","text":"A program in Unix is a sequence of executable instructions. Apart from all its aspects, the only one that is of interest to us is the fact that a program is a sequence of instructions and data (on disk) that may potentially be executed at some point in time, maybe even multiple times, maybe even concurrently. Processes , in the other hand, are like a \"structure\" that wraps a running program and manages it, guarding its state, current directories, file handles, privileges and so on. You can run a program more than once, concurrently. For example, you can run two instances of a text editor, which edit two different texts. program and initial data are the same: it is the same editor. But the state inside each process is different: the text, the insert mode, cursor position and so on. From a programmers point of view, \u201cthe code is the same, but the variable values are different.","title":"Processes and programs"},{"location":"processes/readme/#user-and-kernel-mode","text":"Whenever a Unix process does a system call (and at some other opportunities) the current process leaves the user context and the operating system code is being activated. This is privileged kernel code, and the activation is not quite a subroutine call, because not only is privileged mode activated, but also a kernel stack is being used and the CPU registers of the user process are saved. The kernel will then execute the system call on behalf of the user program, and then will try to exit the kernel. The typical way to leave the kernel is through the scheduler. The scheduler will review the process list and current situation. It will then decide into which of all the different user processes to exit. It will restore the chosen processes registers, then return into this processes context, using this processes stack. The chosen process may or may not be the one that made the system call. In short: Whenever you make a system call, you may (or may not) lose the CPU to another process . That\u2019s not too bad, because this other process at some point has to give up the CPU and the kernel will then return into our process as if nothing happened. Our program is not being executed linearly, but in a sequence of subjectively linear segments, with breaks inbetween. During these breaks the CPU is working on segments of other processes that are also runnable.","title":"User and Kernel mode"},{"location":"processes/readme/#visual-representation","text":"In the diagram below we can see that the entity program is contained inside the entity process . Also, we can see that different process can comunicate between each other freely. However, in order to comunicate with the hardware, user processes must make system calls and have Kernel do it for them.","title":"Visual representation"},{"location":"signals/readme/","text":"","title":"Signals"},{"location":"sys-calls/01-fork/readme/","text":"pid_t fork(void) In traditional Unix the only way to create a process is using the fork() system call. The new process gets a copy of the current program, but new process id ( pid ). The process id of the parent process (the process that called fork() ) is registered as the new processes parent pid (ppid) to build a process tree. In the parent process, fork() returns and delivers the new processe's pid as a result. The new process also returns from the fork() system call (because that is when the copy was made), but the result of the fork() is 0. So fork() is a special system call. You call it once, but the function returns twice: Once in the parent, and once in the child process. fork() increases the number of processes in the system by one. Every Unix process always starts their existence by returning from a fork() system call with a 0 result, running the same program as the parent process. They can have different fates because the result of the fork() system call is different in the parent and child incarnation, and that can drive execution down different if() branches. In Code: #include <stdio.h> #include <unistd.h> #include <stdlib.h> int main () { pid_t pid = fork (); if ( pid < 0 ) { perror ( \"In fork():\" ); return -1 ; } if ( pid == 0 ) { printf ( \"I am the child. \\n \" ); } if ( pid > 0 ) { printf ( \"I am the parent, the child is %d. \\n \" , pid ); } return 0 ; } Running this, we get: pedro@ubuntu:~/Desktop/superprof/guilherme/aula-01/fork$ gcc ex01.c -o ex01 pedro@ubuntu:~/Desktop/superprof/guilherme/aula-01/fork$ ./ex01 I am the parent, the child is 3764. I am the child. We are defining a variable pid of the type pid_t. This variable saves the fork() result, and using it we activate one (\u201cI am the child.\u201d) or the other (\u201cI am the parent\u201d) branch of an if(). Running the program we get two result lines. Since we have only one variable, and this variable can have only one state, an instance of the program can only be in either one or the other branch of the code. Since we see two lines of output, two instances of the program with different values for pid must have been running. If we called getpid() and printed the result we could prove this by showing two different pids . Visual representation # If we abstract things and see only the blocks containing this example, it would look something like this: And when it comes to sequence in the actual code, this is what happens:","title":"01. Fork"},{"location":"sys-calls/01-fork/readme/#visual-representation","text":"If we abstract things and see only the blocks containing this example, it would look something like this: And when it comes to sequence in the actual code, this is what happens:","title":"Visual representation"},{"location":"sys-calls/02-exit/readme/","text":"void exit(int status) The fork() system call is entered once, but left twice, and increments the number of processes in the system by one. After finishing our program the number of processes in the system is as large as before. That means there must be another system call which decrements the number of system calls. This system call is exit() . Exit() is a system call you enter once and never leave. It decrements the number of processes in the system by one. It also accepts an exit status as a parameter, which the parent process can receive (or even has to receive), and which communicates the fate of the child to the parent. Exit() closes all files and sockets, frees all memory and then terminates the process. The parameter of exit() is the only thing that survives and is handed over to the parent process.","title":"02. Exit"},{"location":"sys-calls/03-wait/readme/","text":"pid_t wait(int *wstatus); Our child process ends with an exit(0) . The 0 is the exit status of our program and can be shipped. We need to make the parent process pick up this value and we need a new system call for this. This system call is wait() . In Code: #include <stdio.h> #include <unistd.h> #include <stdlib.h> #include <sys/types.h> #include <sys/wait.h> int main () { pid_t pid = 0 ; int status ; pid = fork (); if ( pid == 0 ) { printf ( \"I am the child. \\n \" ); sleep ( 10 ); printf ( \"I am the child, 10 seconds later. \\n \" ); } if ( pid > 0 ) { printf ( \"I am the parent, the child is %d. \\n \" , pid ); pid = wait ( & status ); printf ( \"End of process %d: \" , pid ); if ( WIFEXITED ( status )) { printf ( \"The process ended with return code(%d). \\n \" , WEXITSTATUS ( status )); } if ( WIFSIGNALED ( status )) { printf ( \"The process ended with kill -%d. \\n \" , WTERMSIG ( status )); } } if ( pid < 0 ) { perror ( \"In fork():\" ); } return 0 ; } Running this, we get: pedro@ubuntu:~/Desktop/superprof/guilherme/aula-01/wait$ gcc ex01.c -o ex01 pedro@ubuntu:~/Desktop/superprof/guilherme/aula-01/wait$ ./ex01 I am the parent, the child is 4064. I am the child. I am the child, 10 seconds later. End of process 4064: The process ended with return code (0). The variable status is passed to the system call wait() as a reference parameter, and will be overwritten by it. The value is a bitfield, containing the exit status and additional reasons explaining how the program ended. To decode this, C offers a number of macros with predicates such as WIFEXITED() or WIFSIGNALED() . We also get extractors, such as WEXITSTATUS() and WTERMSIG() . wait() also returns the pid of the process that terminated, as a function result. Wait() stops execution of the parent process until either a signal arrives or a child process terminates. You can arrange for a SIGALARM to be sent to you in order to time bound the wait() .","title":"03. Wait"},{"location":"sys-calls/04-exec/readme/","text":"So while fork() makes processes, exec() loads programs into processes that already exist. Exec() has many variantes ( execl , execlp , execv , execvp , execle and so on and so forth), here we will be taking a look at execl , but in general they all do the same. Execl # int execl(const char *path, const char *arg, ..., NULL); The function takes the path of the executable binary file (i.e. /bin/ls ) as the first and second argument. Then, the arguments (i.e. -lh , /home ) that you want to pass to the executable followed by NULL . Then execl() system function runs the command and load the target binary into the currnt process. If any error occurs, then execl() returns -1. Otherwise, it returns nothing and the new program starts running. Notice that all data related to the original program is completely lost. In code: #include <unistd.h> int main ( void ) { char * binaryPath = \"/bin/ls\" ; char * arg1 = \"-lh\" ; char * arg2 = \"/home/pedro/Desktop/superprof/guilherme\" ; execl ( binaryPath , binaryPath , arg1 , arg2 , NULL ); return 0 ; } Running this, we get: pedro@ubuntu:~/Desktop/superprof/guilherme/aula-01/exec$ gcc ex01.c -o ex01 pedro@ubuntu:~/Desktop/superprof/guilherme/aula-01/exec$ ./ex01 total 12K drwxrwxr-x 2 pedro pedro 4,0K mar 24 23:37 aula-00 drwxrwxr-x 5 pedro pedro 4,0K mar 26 14:38 aula-01 drwxrwxr-x 3 pedro pedro 4,0K mar 26 14:31 aula-02","title":"04. Exec"},{"location":"sys-calls/04-exec/readme/#execl","text":"int execl(const char *path, const char *arg, ..., NULL); The function takes the path of the executable binary file (i.e. /bin/ls ) as the first and second argument. Then, the arguments (i.e. -lh , /home ) that you want to pass to the executable followed by NULL . Then execl() system function runs the command and load the target binary into the currnt process. If any error occurs, then execl() returns -1. Otherwise, it returns nothing and the new program starts running. Notice that all data related to the original program is completely lost. In code: #include <unistd.h> int main ( void ) { char * binaryPath = \"/bin/ls\" ; char * arg1 = \"-lh\" ; char * arg2 = \"/home/pedro/Desktop/superprof/guilherme\" ; execl ( binaryPath , binaryPath , arg1 , arg2 , NULL ); return 0 ; } Running this, we get: pedro@ubuntu:~/Desktop/superprof/guilherme/aula-01/exec$ gcc ex01.c -o ex01 pedro@ubuntu:~/Desktop/superprof/guilherme/aula-01/exec$ ./ex01 total 12K drwxrwxr-x 2 pedro pedro 4,0K mar 24 23:37 aula-00 drwxrwxr-x 5 pedro pedro 4,0K mar 26 14:38 aula-01 drwxrwxr-x 3 pedro pedro 4,0K mar 26 14:31 aula-02","title":"Execl"}]}