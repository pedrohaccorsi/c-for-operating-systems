{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to C for Operating Systems! # This is an online trainning, in which we will discuss Operating System concepts with a hands-on methodology. By the end of this course you'll have solid understanding of: Unix processes signals hierarchy C syscalls programming guidelines good practices Useful links # TBD","title":"Home"},{"location":"#welcome-to-c-for-operating-systems","text":"This is an online trainning, in which we will discuss Operating System concepts with a hands-on methodology. By the end of this course you'll have solid understanding of: Unix processes signals hierarchy C syscalls programming guidelines good practices","title":"Welcome to C for Operating Systems!"},{"location":"#useful-links","text":"TBD","title":"Useful links"},{"location":"processes/readme/","text":"Processes and programs # A program in Unix is a sequence of executable instructions. Apart from all its aspects, the only one that is of interest to us is the fact that a program is a sequence of instructions and data (on disk) that may potentially be executed at some point in time, maybe even multiple times, maybe even concurrently. Processes , in the other hand, are like a \"structure\" that wraps a running program and manages it, guarding its state, current directories, file handles, privileges and so on. You can run a program more than once, concurrently. For example, you can run two instances of a text editor, which edit two different texts. program and initial data are the same: it is the same editor. But the state inside each process is different: the text, the insert mode, cursor position and so on. From a programmers point of view, \u201cthe code is the same, but the variable values are different. User and Kernel mode # Whenever a Unix process does a system call (and at some other opportunities) the current process leaves the user context and the operating system code is being activated. This is privileged kernel code, and the activation is not quite a subroutine call, because not only is privileged mode activated, but also a kernel stack is being used and the CPU registers of the user process are saved. The kernel will then execute the system call on behalf of the user program, and then will try to exit the kernel. The typical way to leave the kernel is through the scheduler. The scheduler will review the process list and current situation. It will then decide into which of all the different user processes to exit. It will restore the chosen processes registers, then return into this processes context, using this processes stack. The chosen process may or may not be the one that made the system call. In short: Whenever you make a system call, you may (or may not) lose the CPU to another process . That\u2019s not too bad, because this other process at some point has to give up the CPU and the kernel will then return into our process as if nothing happened. Our program is not being executed linearly, but in a sequence of subjectively linear segments, with breaks inbetween. During these breaks the CPU is working on segments of other processes that are also runnable. Visual representation # In the diagram below we can see that the entity program is contained inside the entity process . Also, we can see that different process can comunicate between each other freely. However, in order to comunicate with the hardware, user processes must make system calls and have Kernel do it for them.","title":"Processes"},{"location":"processes/readme/#processes-and-programs","text":"A program in Unix is a sequence of executable instructions. Apart from all its aspects, the only one that is of interest to us is the fact that a program is a sequence of instructions and data (on disk) that may potentially be executed at some point in time, maybe even multiple times, maybe even concurrently. Processes , in the other hand, are like a \"structure\" that wraps a running program and manages it, guarding its state, current directories, file handles, privileges and so on. You can run a program more than once, concurrently. For example, you can run two instances of a text editor, which edit two different texts. program and initial data are the same: it is the same editor. But the state inside each process is different: the text, the insert mode, cursor position and so on. From a programmers point of view, \u201cthe code is the same, but the variable values are different.","title":"Processes and programs"},{"location":"processes/readme/#user-and-kernel-mode","text":"Whenever a Unix process does a system call (and at some other opportunities) the current process leaves the user context and the operating system code is being activated. This is privileged kernel code, and the activation is not quite a subroutine call, because not only is privileged mode activated, but also a kernel stack is being used and the CPU registers of the user process are saved. The kernel will then execute the system call on behalf of the user program, and then will try to exit the kernel. The typical way to leave the kernel is through the scheduler. The scheduler will review the process list and current situation. It will then decide into which of all the different user processes to exit. It will restore the chosen processes registers, then return into this processes context, using this processes stack. The chosen process may or may not be the one that made the system call. In short: Whenever you make a system call, you may (or may not) lose the CPU to another process . That\u2019s not too bad, because this other process at some point has to give up the CPU and the kernel will then return into our process as if nothing happened. Our program is not being executed linearly, but in a sequence of subjectively linear segments, with breaks inbetween. During these breaks the CPU is working on segments of other processes that are also runnable.","title":"User and Kernel mode"},{"location":"processes/readme/#visual-representation","text":"In the diagram below we can see that the entity program is contained inside the entity process . Also, we can see that different process can comunicate between each other freely. However, in order to comunicate with the hardware, user processes must make system calls and have Kernel do it for them.","title":"Visual representation"},{"location":"signals/introduction/readme/","text":"What are signals # Signals are Software interruptions that happen due to either Software pre-definition or hardware exceptions. For example, it could happen in divisions by zero, or unauthorized attempt of memory access. In general, we can understand signals as way to send information from the OS to our user processes. Examples of signals # Signals will start with the prefix SIG , and will have specific use cases. Below is a list with the most common ones: signal value description SIGHUP 1 Hangup (POSIX) Report that user's terminal is disconnected. Signal used to report the termination of the controlling process. SIGINT 2 Interrupt (ANSI) Program interrupt (ctrl-c) SIGQUIT 3 Quit (POSIX) Terminate process and generate core dump. SIGILL 4 Illegal Instruction (ANSI) Generally indicates that the executable file is corrupted or use of data where a pointer to a function was expected. SIGTRAP 5 Trace trap (POSIX) SIGABRT SIGIOT 6 Abort (ANSI) IOT trap (4.2 BSD) Process detects error and reports by calling abort SIGBUS 7 BUS error (4.2 BSD) Indicates an access to an invalid address. SIGFPE 8 Floating-Point arithmetic Exception (ANSI). This includes division by zero and overflow. The IEEE Standard for Binary Floating-Point Arithmetic (ANSI/IEEE Std 754-1985) defines various floating-point exceptions SIGKILL 9 Kill, unblockable (POSIX) Cause immediate program termination. CanNot be handled, blocked or ignored. SIGUSR1 10 User-defined signal 1 SIGSEGV 11 Segmentation Violation (ANSI) Occurs When a program tries to read or write outside the memory that is allocated for it by the operating system, dereferencing a bad or NULL pointer. Indicates an invalid access to valid memory. SIGUSR2 12 User-defined signal 2 SIGPIPE 13 Broken pipe (POSIX) Error condition like trying to write to a socket which is not connected. SIGALRM 14 Alarm clock (POSIX) Indicates expiration of a timer. Used by the alarm() function. SIGTERM 15 Termination (ANSI) This signal can be blocked, handled, and ignored. Generated by \"kill\" command. SIGSTKFLT 16 Stack fault SIGCHLD SIGCLD 17 Child status has changed (POSIX) Signal sent to parent process whenever one of its child processes terminates or stops. See the YoLinux.com Fork, exec, wait, waitpid tutorial SIGCONT 18 Continue (POSIX) Signal sent to process to make it continue. Visual representation # As show below, the signal comes from outside the process. It will stop the current flow of the process so that it can be handled, and then it will go back to where it was before the signal.","title":"Introduction"},{"location":"signals/introduction/readme/#what-are-signals","text":"Signals are Software interruptions that happen due to either Software pre-definition or hardware exceptions. For example, it could happen in divisions by zero, or unauthorized attempt of memory access. In general, we can understand signals as way to send information from the OS to our user processes.","title":"What are signals"},{"location":"signals/introduction/readme/#examples-of-signals","text":"Signals will start with the prefix SIG , and will have specific use cases. Below is a list with the most common ones: signal value description SIGHUP 1 Hangup (POSIX) Report that user's terminal is disconnected. Signal used to report the termination of the controlling process. SIGINT 2 Interrupt (ANSI) Program interrupt (ctrl-c) SIGQUIT 3 Quit (POSIX) Terminate process and generate core dump. SIGILL 4 Illegal Instruction (ANSI) Generally indicates that the executable file is corrupted or use of data where a pointer to a function was expected. SIGTRAP 5 Trace trap (POSIX) SIGABRT SIGIOT 6 Abort (ANSI) IOT trap (4.2 BSD) Process detects error and reports by calling abort SIGBUS 7 BUS error (4.2 BSD) Indicates an access to an invalid address. SIGFPE 8 Floating-Point arithmetic Exception (ANSI). This includes division by zero and overflow. The IEEE Standard for Binary Floating-Point Arithmetic (ANSI/IEEE Std 754-1985) defines various floating-point exceptions SIGKILL 9 Kill, unblockable (POSIX) Cause immediate program termination. CanNot be handled, blocked or ignored. SIGUSR1 10 User-defined signal 1 SIGSEGV 11 Segmentation Violation (ANSI) Occurs When a program tries to read or write outside the memory that is allocated for it by the operating system, dereferencing a bad or NULL pointer. Indicates an invalid access to valid memory. SIGUSR2 12 User-defined signal 2 SIGPIPE 13 Broken pipe (POSIX) Error condition like trying to write to a socket which is not connected. SIGALRM 14 Alarm clock (POSIX) Indicates expiration of a timer. Used by the alarm() function. SIGTERM 15 Termination (ANSI) This signal can be blocked, handled, and ignored. Generated by \"kill\" command. SIGSTKFLT 16 Stack fault SIGCHLD SIGCLD 17 Child status has changed (POSIX) Signal sent to parent process whenever one of its child processes terminates or stops. See the YoLinux.com Fork, exec, wait, waitpid tutorial SIGCONT 18 Continue (POSIX) Signal sent to process to make it continue.","title":"Examples of signals"},{"location":"signals/introduction/readme/#visual-representation","text":"As show below, the signal comes from outside the process. It will stop the current flow of the process so that it can be handled, and then it will go back to where it was before the signal.","title":"Visual representation"},{"location":"signals/signal-generation/readme/","text":"Generating signals via SHELL # We can send signals to a process via shell with the command kill . This command can send a given process any signal. For example, let's send the signal SIGUSR1 to the process with pid 1234: $ kill -USR1 1234 Besides using kill to send signals to a process of our choose, we can also use some special key bindings to send signals to the foreground process we are executing. Some usual signals handled by default are: key binding signal Ctrl + C SIGINT Ctrl + \\ SIGQUIT Ctrl + Z SIGTSTP Generating via code # An easy way to send signals via code is with the function kill() defined in <signal.h> int kill(pid_t pid, int sig); This function will send the signal sig to the process with process id pid , and return an int to let the caller know what happened: 0 means at least one signal was sent -1 means error, and errno is set to indicate the error. Example: #include <stdio.h> #include <unistd.h> #include <stdlib.h> #include <signal.h> #include <sys/wait.h> int main (){ pid_t fork_pid = fork (); int status ; if ( fork_pid == 0 ){ for (;;); } if ( fork_pid > 0 ){ kill ( fork_pid , SIGTERM ); } wait ( & status ); printf ( \"Child process was terminated successfuly! \\n \" ); return 0 ; } Running this, we get: pedro@ubuntu:~/Desktop/superprof/guilherme/aula-02/signal-handling$ gcc signal-example.c -o signal-example pedro@ubuntu:~/Desktop/superprof/guilherme/aula-02/signal-handling$ ./signal-example Child process was terminated successfuly! The code above will create a child process that will be stuck inside an infinite loop: if ( fork_pid = 0 ){ for (;;); } But not for too long, since the parent process will send a SIGTERM signal to the child, making it terminate immediately: if ( fork_pid > 0 ){ kill ( fork_pid , SIGTERM ); } And we can make sure that it works because we actually tell the parent signal to wait for the child. This means that if we didn't kill the child, the parent process would never reach the printf() line. wait (); printf ( \"Child process was terminated successfuly!\" ); As it does, we can tell that the killing worked as expected.","title":"Generating signals"},{"location":"signals/signal-generation/readme/#generating-signals-via-shell","text":"We can send signals to a process via shell with the command kill . This command can send a given process any signal. For example, let's send the signal SIGUSR1 to the process with pid 1234: $ kill -USR1 1234 Besides using kill to send signals to a process of our choose, we can also use some special key bindings to send signals to the foreground process we are executing. Some usual signals handled by default are: key binding signal Ctrl + C SIGINT Ctrl + \\ SIGQUIT Ctrl + Z SIGTSTP","title":"Generating signals via SHELL"},{"location":"signals/signal-generation/readme/#generating-via-code","text":"An easy way to send signals via code is with the function kill() defined in <signal.h> int kill(pid_t pid, int sig); This function will send the signal sig to the process with process id pid , and return an int to let the caller know what happened: 0 means at least one signal was sent -1 means error, and errno is set to indicate the error. Example: #include <stdio.h> #include <unistd.h> #include <stdlib.h> #include <signal.h> #include <sys/wait.h> int main (){ pid_t fork_pid = fork (); int status ; if ( fork_pid == 0 ){ for (;;); } if ( fork_pid > 0 ){ kill ( fork_pid , SIGTERM ); } wait ( & status ); printf ( \"Child process was terminated successfuly! \\n \" ); return 0 ; } Running this, we get: pedro@ubuntu:~/Desktop/superprof/guilherme/aula-02/signal-handling$ gcc signal-example.c -o signal-example pedro@ubuntu:~/Desktop/superprof/guilherme/aula-02/signal-handling$ ./signal-example Child process was terminated successfuly! The code above will create a child process that will be stuck inside an infinite loop: if ( fork_pid = 0 ){ for (;;); } But not for too long, since the parent process will send a SIGTERM signal to the child, making it terminate immediately: if ( fork_pid > 0 ){ kill ( fork_pid , SIGTERM ); } And we can make sure that it works because we actually tell the parent signal to wait for the child. This means that if we didn't kill the child, the parent process would never reach the printf() line. wait (); printf ( \"Child process was terminated successfuly!\" ); As it does, we can tell that the killing worked as expected.","title":"Generating via code"},{"location":"signals/signal-handling/readme/","text":"APIs # There are many APIs in C to handle signals, the most known are: Lib function ANSI-C signal() SystemV sigset(), sysv_signal() BSD sigvec(), bsd_signal() POSIX sigaction() POSIX # Let's focus our studies on the POSIX lib. The function sigaction() has the following syntax: int sigaction ( int signum , const struct sigaction * act , struct sigaction * oldact ) The sigaction structure is defined as something like: struct sigaction { void ( * sa_handler )( int ); //signal handler function void ( * sa_sigaction )( int , siginfo_t * , void * ); //RT signal handler sigset_t sa_mask ; //mask for blocked signals int sa_flags ; //mods for signal handling void ( * sa_restorer )( void ); }; POSIX Example # void signal_handler ( int signal ){ printf ( \"received the signal: %d \\n \" , signal ); } int maint (){ struct sigaction signal_action ; memset ( & signal_action , 0 , sizeof ( signal_action )); signal_action . sa_handler = & signal_handler ; if ( sigaction ( SIGUSR1 , & signal_action , NULL ) ) != 0 ){ perror ( \"Fail on installing signal handler!\" ); return -1 ; } for (;;); return 0 ; } The code above has 4 main steps: 1) declare (and implement) the signal handler function: void signal_handler ( int signal ){ printf ( \"received the signal: %d \\n \" , signal ); } 2) Declare (and initialize) the sigaction structure. struct sigaction signal_action ; memset ( & signal_action , 0 , sizeof ( signal_action )); 3) Assign the function from step 1 into the structure of step 2 signal_action . sa_handler = & signal_handler ; 4) Attach the handler to a specific signal: sigaction ( SIGUSR1 , & signal_action , NULL ) And done!!Now if another process sends the signal SIGUSR1 to this one, it will print the message received the signal 10 ;","title":"Handling signals"},{"location":"signals/signal-handling/readme/#apis","text":"There are many APIs in C to handle signals, the most known are: Lib function ANSI-C signal() SystemV sigset(), sysv_signal() BSD sigvec(), bsd_signal() POSIX sigaction()","title":"APIs"},{"location":"signals/signal-handling/readme/#posix","text":"Let's focus our studies on the POSIX lib. The function sigaction() has the following syntax: int sigaction ( int signum , const struct sigaction * act , struct sigaction * oldact ) The sigaction structure is defined as something like: struct sigaction { void ( * sa_handler )( int ); //signal handler function void ( * sa_sigaction )( int , siginfo_t * , void * ); //RT signal handler sigset_t sa_mask ; //mask for blocked signals int sa_flags ; //mods for signal handling void ( * sa_restorer )( void ); };","title":"POSIX"},{"location":"signals/signal-handling/readme/#posix-example","text":"void signal_handler ( int signal ){ printf ( \"received the signal: %d \\n \" , signal ); } int maint (){ struct sigaction signal_action ; memset ( & signal_action , 0 , sizeof ( signal_action )); signal_action . sa_handler = & signal_handler ; if ( sigaction ( SIGUSR1 , & signal_action , NULL ) ) != 0 ){ perror ( \"Fail on installing signal handler!\" ); return -1 ; } for (;;); return 0 ; } The code above has 4 main steps: 1) declare (and implement) the signal handler function: void signal_handler ( int signal ){ printf ( \"received the signal: %d \\n \" , signal ); } 2) Declare (and initialize) the sigaction structure. struct sigaction signal_action ; memset ( & signal_action , 0 , sizeof ( signal_action )); 3) Assign the function from step 1 into the structure of step 2 signal_action . sa_handler = & signal_handler ; 4) Attach the handler to a specific signal: sigaction ( SIGUSR1 , & signal_action , NULL ) And done!!Now if another process sends the signal SIGUSR1 to this one, it will print the message received the signal 10 ;","title":"POSIX Example"},{"location":"sys-calls/01-fork/readme/","text":"pid_t fork(void) In traditional Unix the only way to create a process is using the fork() system call. The new process gets a copy of the current program, but new process id ( pid ). The process id of the parent process (the process that called fork() ) is registered as the new processes parent pid (ppid) to build a process tree. In the parent process, fork() returns and delivers the new processe's pid as a result. The new process also returns from the fork() system call (because that is when the copy was made), but the result of the fork() is 0. So fork() is a special system call. You call it once, but the function returns twice: Once in the parent, and once in the child process. fork() increases the number of processes in the system by one. Every Unix process always starts their existence by returning from a fork() system call with a 0 result, running the same program as the parent process. They can have different fates because the result of the fork() system call is different in the parent and child incarnation, and that can drive execution down different if() branches. In Code: #include <stdio.h> #include <unistd.h> #include <stdlib.h> int main () { pid_t pid = fork (); if ( pid < 0 ) { perror ( \"In fork():\" ); return -1 ; } if ( pid == 0 ) { printf ( \"I am the child. \\n \" ); } if ( pid > 0 ) { printf ( \"I am the parent, the child is %d. \\n \" , pid ); } return 0 ; } Running this, we get: pedro@ubuntu:~/Desktop/superprof/guilherme/aula-01/fork$ gcc ex01.c -o ex01 pedro@ubuntu:~/Desktop/superprof/guilherme/aula-01/fork$ ./ex01 I am the parent, the child is 3764. I am the child. We are defining a variable pid of the type pid_t. This variable saves the fork() result, and using it we activate one (\u201cI am the child.\u201d) or the other (\u201cI am the parent\u201d) branch of an if(). Running the program we get two result lines. Since we have only one variable, and this variable can have only one state, an instance of the program can only be in either one or the other branch of the code. Since we see two lines of output, two instances of the program with different values for pid must have been running. If we called getpid() and printed the result we could prove this by showing two different pids . Visual representation # If we abstract things and see only the blocks containing this example, it would look something like this: And when it comes to sequence in the actual code, this is what happens:","title":"01. Fork"},{"location":"sys-calls/01-fork/readme/#visual-representation","text":"If we abstract things and see only the blocks containing this example, it would look something like this: And when it comes to sequence in the actual code, this is what happens:","title":"Visual representation"},{"location":"sys-calls/02-exit/readme/","text":"void exit(int status) The fork() system call is entered once, but left twice, and increments the number of processes in the system by one. After finishing our program the number of processes in the system is as large as before. That means there must be another system call which decrements the number of system calls. This system call is exit() . Exit() is a system call you enter once and never leave. It decrements the number of processes in the system by one. It also accepts an exit status as a parameter, which the parent process can receive (or even has to receive), and which communicates the fate of the child to the parent. Exit() closes all files and sockets, frees all memory and then terminates the process. The parameter of exit() is the only thing that survives and is handed over to the parent process.","title":"02. Exit"},{"location":"sys-calls/03-wait/readme/","text":"pid_t wait(int *wstatus); Our child process ends with an exit(0) . The 0 is the exit status of our program and can be shipped. We need to make the parent process pick up this value and we need a new system call for this. This system call is wait() . In Code: #include <stdio.h> #include <unistd.h> #include <stdlib.h> #include <sys/types.h> #include <sys/wait.h> int main () { pid_t pid = 0 ; int status ; pid = fork (); if ( pid == 0 ) { printf ( \"I am the child. \\n \" ); sleep ( 10 ); printf ( \"I am the child, 10 seconds later. \\n \" ); } if ( pid > 0 ) { printf ( \"I am the parent, the child is %d. \\n \" , pid ); pid = wait ( & status ); printf ( \"End of process %d: \" , pid ); if ( WIFEXITED ( status )) { printf ( \"The process ended with return code(%d). \\n \" , WEXITSTATUS ( status )); } if ( WIFSIGNALED ( status )) { printf ( \"The process ended with kill -%d. \\n \" , WTERMSIG ( status )); } } if ( pid < 0 ) { perror ( \"In fork():\" ); } return 0 ; } Running this, we get: pedro@ubuntu:~/Desktop/superprof/guilherme/aula-01/wait$ gcc ex01.c -o ex01 pedro@ubuntu:~/Desktop/superprof/guilherme/aula-01/wait$ ./ex01 I am the parent, the child is 4064. I am the child. I am the child, 10 seconds later. End of process 4064: The process ended with return code (0). The variable status is passed to the system call wait() as a reference parameter, and will be overwritten by it. The value is a bitfield, containing the exit status and additional reasons explaining how the program ended. To decode this, C offers a number of macros with predicates such as WIFEXITED() or WIFSIGNALED() . We also get extractors, such as WEXITSTATUS() and WTERMSIG() . wait() also returns the pid of the process that terminated, as a function result. Wait() stops execution of the parent process until either a signal arrives or a child process terminates. You can arrange for a SIGALARM to be sent to you in order to time bound the wait() .","title":"03. Wait"},{"location":"sys-calls/04-exec/readme/","text":"So while fork() makes processes, exec() loads programs into processes that already exist. Exec() has many variantes ( execl , execlp , execv , execvp , execle and so on and so forth), here we will be taking a look at execl , but in general they all do the same. Execl # int execl(const char *path, const char *arg, ..., NULL); The function takes the path of the executable binary file (i.e. /bin/ls ) as the first and second argument. Then, the arguments (i.e. -lh , /home ) that you want to pass to the executable followed by NULL . Then execl() system function runs the command and load the target binary into the currnt process. If any error occurs, then execl() returns -1. Otherwise, it returns nothing and the new program starts running. Notice that all data related to the original program is completely lost. In code: #include <unistd.h> int main ( void ) { char * binaryPath = \"/bin/ls\" ; char * arg1 = \"-lh\" ; char * arg2 = \"/home/pedro/Desktop/superprof/guilherme\" ; execl ( binaryPath , binaryPath , arg1 , arg2 , NULL ); return 0 ; } Running this, we get: pedro@ubuntu:~/Desktop/superprof/guilherme/aula-01/exec$ gcc ex01.c -o ex01 pedro@ubuntu:~/Desktop/superprof/guilherme/aula-01/exec$ ./ex01 total 12K drwxrwxr-x 2 pedro pedro 4,0K mar 24 23:37 aula-00 drwxrwxr-x 5 pedro pedro 4,0K mar 26 14:38 aula-01 drwxrwxr-x 3 pedro pedro 4,0K mar 26 14:31 aula-02","title":"04. Exec"},{"location":"sys-calls/04-exec/readme/#execl","text":"int execl(const char *path, const char *arg, ..., NULL); The function takes the path of the executable binary file (i.e. /bin/ls ) as the first and second argument. Then, the arguments (i.e. -lh , /home ) that you want to pass to the executable followed by NULL . Then execl() system function runs the command and load the target binary into the currnt process. If any error occurs, then execl() returns -1. Otherwise, it returns nothing and the new program starts running. Notice that all data related to the original program is completely lost. In code: #include <unistd.h> int main ( void ) { char * binaryPath = \"/bin/ls\" ; char * arg1 = \"-lh\" ; char * arg2 = \"/home/pedro/Desktop/superprof/guilherme\" ; execl ( binaryPath , binaryPath , arg1 , arg2 , NULL ); return 0 ; } Running this, we get: pedro@ubuntu:~/Desktop/superprof/guilherme/aula-01/exec$ gcc ex01.c -o ex01 pedro@ubuntu:~/Desktop/superprof/guilherme/aula-01/exec$ ./ex01 total 12K drwxrwxr-x 2 pedro pedro 4,0K mar 24 23:37 aula-00 drwxrwxr-x 5 pedro pedro 4,0K mar 26 14:38 aula-01 drwxrwxr-x 3 pedro pedro 4,0K mar 26 14:31 aula-02","title":"Execl"}]}